#include <bits/stdc++.h>
using namespace std;

vector<int> add(vector<int> A, vector<int> B);
vector<int> sub(vector<int> A, vector<int> B);
bool subCmp(vector<int> A, vector<int> B);
vector<int> mul(vector<int> A, vector<int> B);
vector<int> div(vector<int> A, int b, int* r);

int main()
{

	//大数高精
	//对于超级无敌大的数之间的运算，超出int之外，不在long long之中，如何处理？当然是模拟竖式计算！！！
	string a;
	cin >> a;       //假如输入1234  则a[0]='1' a[1]='2 a[2]='3' a[3]='4'
	//此时再来一个加数9124
	//       1234           模拟竖式计算
	//     + 9124
	//      10358

	//此时会出现一个问题，因为数字的高位为a[0],当出现进位问题时，由于前面的位数已经确定，包括a[0],进位需要额外的位置，但是没有，因此需要想办法
	//如果把位置倒置，即a[0]为最低位，则如果进位就不会出现没有位置的问题，于是需要进行颠倒操作

	vector <int> A;
	for (int i = a.size() - 1; i >= 0; i--)      //用容器存放，倒着存
	{
		A.push_back(a[i] - '0');     //a为字符串，因此a[i]为char，char变成其字符注意-'0'   ！！！
	}

	//现在开始以3456+789为例编写高精加法
	//      3456
	//   +   789
	//      4245

	string b;    //录入加数，同上
	cin >> b;
	vector <int> B, C;
	for (int i = b.size() - 1; i >= 0; i--)
	{
		B.push_back(b[i] - '0');
	}

	C = add(A, B);

	for (int i = C.size() - 1; i >= 0; i--)
	{
		cout << C[i];
	}
	cout << endl;


	/*------------------------------------------------分割线----------------------------------------------------------*/


		//接下来是减法，原理与加法相同，但是有细节区别
	C.clear();    //清除数据

	//这里出现一个问题，交换之后答案也会变，需要在函数外提前搞定并取负
	//还有一个问题，如果长度相同，相减也会出现负数，因此写一个方法专门判断尤为重要
	if (subCmp(A, B)) C = sub(A, B);    //如果函数返回true，不管哪种情况都说明A大于等于B，可以直接做差
	else    //反正，处理负数情况
	{
		C = sub(B, A);   //提前写上负号
		cout << '-';
	}
	for (int i = C.size() - 1; i >= 0; i--)
	{
		cout << C[i];
	}
	cout << endl;



	/*------------------------------------------------分割线----------------------------------------------------------*/


		//乘法
	C.clear();
	C = mul(A, B);     //在有前面加法减法的铺垫下，乘法格外简单
	for (int i = C.size() - 1; i >= 0; i--)
	{
		cout << C[i];
	}
	cout << endl;

	/*------------------------------------------------分割线----------------------------------------------------------*/
		//除法
		C.clear();
		int r = 0;    //余数
		long long m = stoll(b);
		
		if (m == 0) cout << "error";    //这里有一个除零操作的判断
		else
		{
			C = div(A, m, &r);
			for (int i = C.size() - 1; i >= 0; i--)
			{
				cout << C[i];
			}
			cout << endl << r;
		}
		cout << endl;

	/*------------------------------------------------分割线----------------------------------------------------------*/

	return 0;
}

vector<int> add(vector<int> A, vector<int> B)    //传出C，传入任意两个加数，不分顺序
{
	if (A.size() < B.size()) return add(B, A);     //在这里考虑顺序，为了方便计算，将长的作为被加数，短的作为加数，如果第一个短，则互换
	vector<int> C;
	int t = 0;    //进位
	for (int i = 0; i < A.size(); i++)
	{
		t += A[i];     //t先+=A[i]，因为B是短的，B[i]不一定存在    先算进位
		if (i < B.size()) t += B[i];      //如果存在，就加，不存在不加
		C.push_back(t % 10);     //加上t的个位
		t /= 10;      //t/10即可算出进位数，最后计算出进位，准备下一个循环使用
	}
	//循环结束后还有一个问题，假如出现最高位进位（如9456+789，9要进1变成10的情况），但是上面循环无法输出进的1
	//我们发现循环结束后进位变量t不为零，不过不是特殊情况，则t为0，因此只需在循环结束考虑t是否为零即可，如果不是零，就push_back即可
	if (t != 0) C.push_back(t);

	return C;
}


vector<int> sub(vector<int> A, vector<int> B)    //参照add()仿写
{
	vector<int> C;
	int b = 0;     //借位
	for (int i = 0; i < A.size(); i++)
	{
		b = A[i] - b;          ////t先+=A[i]，因为B是短的，B[i]不一定存在    先算进位
		if (i < B.size()) b -= B[i];    //如果存在，就加，不存在不加
		C.push_back((b + 10) % 10);
		b = b < 0 ? 1 : 0;     //b如果小于零，证明借位了，那么b=1，两个数相减，借位最大也就是1了；反之，证明没有借位，b=0即可准备下一次循环
	}
	//由于减法不会出现进位多位的问题，所以不用写加法的进位问题，但是有时答案会出现如0012这种情景，显然我们需要12，这时就出现了一个新的问题：去除前导0！！！
	//去除前导零之前，我们再来回忆一下数据的存储方式，以0012为例，第零个元素为2，第一个元素为1，第三个元素为0，第四个元素为0。也就是说，前导零的位置在尾部
	//另外，还需要考虑一个问题，当答案为0时，或者0000时，第一个元素的0不是前导零，也就是说，去前导零的先决条件是至少两位数
	//最后，考虑如何去除的问题，可以考虑使用.back()取得最后一位数（尾部），当满足上一行的先决条件并且尾部为零，那么条件成立，前导零可以去除
	while (C.size() > 1 && C.back() == 0) C.pop_back();    //这也体现了倒序录入数据的优点

	return C;
}

bool subCmp(vector<int> A, vector<int> B)
{
	if (A.size() != B.size()) return A.size() > B.size();      //与前面main函数对接，如果二位长度不等，那么传一个判断A和B谁大谁小的布尔结果
	for (int i = A.size() - 1; i >= 0; i--)    //如果你侥幸过了上面一关，那么开始判断谁大谁小。判断方法就是从高位到地位，最高位开始，如果二位最高位相等，那么比较下一位
		//如果不相等，那么直接出结果，大者数大
		//再次强调，存入vector里的数据是倒着的，因此最高位在尾部！！！  注意for循环的设置
	{
		if (A[i] != B[i]) return A[i] > B[i];     //和上面的if是一个套路，如果二位不等，则传出一个判断二者大小的布尔，；反之则接着比较
	}
	return true;     //到了最后的最后，二位长度相等，每一位也相等，说明两个数字完全一样
}


vector<int> mul(vector<int> A, vector<int> B)
{
	vector<int> C, D;   //C为最终结果D为缓冲
	int t = 0;    //进位
	C.push_back(0);    //C初始化，方便后面相加操作
	for (int i = 0; i < B.size(); i++)
	{
		for (int j = 0; j < A.size(); j++)    //两个for循环模拟竖式计算
		{
			t += A[j] * B[i];
			D.push_back(t % 10);
			t /= 10;
		}
		while (t != 0)       //这里仍然会出现像加法一样的进位操作，比如2*5=10，C只记录了0，没有记录1，1在t中
		{
			C.push_back(t % 10);
			t /= 10;
		}
		while (C.size() > 1 && C.back() == 0) C.pop_back();    //当出现乘零情况时，仍会出现前导零，因此需要去除前导零
		D.insert(D.begin(), i, 0);     //对D乘以1ei，也就是往后加i个0（如567加1个零变成5670）  这个操作是在模拟竖式每行错位相加
		C = add(C, D);   //调用之前已经写好的add，完成一次相加，循环结束后就是答案
		D.clear();          //清除缓存D
	}

	//这里仍然会出现像加法一样的进位操作，比如2*5=10，C只记录了0，没有记录1，1在t中
	while (t != 0)
	{
		C.push_back(t % 10);
		t /= 10;
	}

	//当出现乘零情况时，仍会出现前导零，因此需要去除前导零
	while (C.size() > 1 && C.back() == 0) C.pop_back();

	return C;
}


vector<int> div(vector<int> A, int b, int* r)
{
	vector<int> C;
	int t = 0;
	for (int i = A.size() - 1; i >= 0; i--)    //从高位到低位取数，注意for循环
	{
		t = A[i] + t * 10;
		C.push_back(t / b);
		t %= b;
	}
	// 这种算法会出现前导零，比如2001 / 32 = 00....
	//现在出现了一个问题，回忆一下加法计算的结果，如果20+20=40 ，则C应该存入“04”，也就是倒着存放
	//再看一下除法得到的C，2000/5=0400，而C中存放的也是“0400”，也就是正序存放，这种存放方式不便于去除前导零，而且与加，减，乘法的输出方式不统一
	//因此我们先让C倒序存放
	reverse(C.begin(), C.end());    //整体颠倒

	while (C.size() > 1 && C.back() == 0) C.pop_back();   //去前导
	*r = t;     //以指针传出余数

	return C;
}
