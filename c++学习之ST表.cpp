//Written By YiGuo
//参考网址：
//https://blog.csdn.net/y6123236/article/details/132902205
#include<bits/stdc++.h>
#define ll long long
#define vi vector<int>
using namespace std;

int st[100][10];  //st表
int num[100];  //原数组
int n, col;  //实际长度

//初始化,包含数据的输入
void init()
{
	//st表中，第一个空表示区间的左端点
	//第二个空表示区间的长度并以2的次方表示
	for (int i = 0; i < n; i++)
	{
		cin >> num[i];
		st[i][0] = num[i];
	}
}

//创建st表
void st_set()
{
	col = (int)(log(n)) / (log(2));
	//第一空长度为n，因为当st表以1个单位长度表示时，长度为n
	//第二空有多大？考虑2的多少次方为n，也就是log2(n)

	//开始写st表  st[i][j]
	for (int j = 1; j <= col; j++)
	{
		//以j为外循环，初始为1表示初始想求的区间长度为2的一次方
		//因为区间长度为2的0次方的操作已经在初始化中实现
		//每次循环j++，直到区间长度达到2的col次方，结束
		for (int i = 0; i <= n - (1 << j); i++)
		{
			//以i为内循环，表示所求区间左端点为i
			//i初始为0，包含左端点为0的情况，合情合理
			//内循环的终止与外循环有关
			//例如，当j=1时，说明所求区间长度为2
			//此时所求区间左端点的最大值往后加2所得的右端点必须有意义
			//因此i在n-2^j处就可以停了
			st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);
			//这里给st表赋值，是min还是max看你想查最大值还是最小值
			//当我想求st[i][j]时，即左端点为i，右端点为i+2^j-1
			//显然可以理解为，这是一个大区间，我们可以通过
			//求两个重合的小区间的最值的最值得到大区间的最值
			//第一个小区间的左端点与大区间一样，都是i
			//但是区间长度不同，小区间的区间长度是大区间的一半
			//也就是2^j-1，因此第一个小区间为st[i][j-1]
			//即左端点为i，右端点为i+2^j-1 -1
			//第二个小区间的左端点自然是第一个小区间右端点+1，即i+2^j-1
			//即i+(1<<(j-1))，用位运算表示2的次方
			//第二个小区间的长度仍然是大区间的一半，即j-1
			//因此第二个小区间为st[i+(1<<(j-1))][j-1]
			//两st在前面循环中均已经算出，都是已知量，求大区间只需比较即可算出
		}
	}
}

//输出st表
void st_out()
{
	//正常遍历二维数组即可
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j <= col; j++)
		{
			cout << st[i][j] << '\t';
		}
		cout << '\n';
	}
}

//查表
/*  这个是O(log(n))查法，用的还是倍增，但是有更好O(1)查法
void st_find()
{
	//st表的创建，目的是快速查询某区间的最值
	//下面讨论如何准确定位区间，以及找到最值。

	//定义所查区间[l,r]
	int l, r;
	cin >> l >> r;

	int len = r - l + 1;   //区间长度
	int ans = num[l];   //答案，暂且定为左端点(只要在区间内都行)

	//开始循环，只要len为正就一直循环
	while (len)
	{
		//中间变量，循环一次+1，从而使2^t整体*2
		int t = 1;
		//我们把区间长度写成二进制，如5，101
		// 5(101) = 1(001) + 4(100)
		//即可以将所求的大区间化作两个小区间，一个长度为1，一个长度为4
		//然而刚才算得的st表中恰好有所有长度为2^n区间的最值
		//只需将这些st找到并且一一比较最值，活到最后的那个值就是ans
		// 怎么比较最低位呢？当然是位运算，只需要len&1即可获取最低位
		//从最低位看，如果该位为1，则可以剥离出一个小区间
		//如果该位为0，则可以等他一手，先把t++，改变下一个小区间的长度
		//接着为下一次比较len的最后一位做准备，
		//我们把已经比较过的旧的最后一位“挤”下去，即右移一位
		//然后新的最后一位上任，准备下一次比较
		if (len & 1)
		{
			ans = min(ans, st[l][t - 1]);
			l = l + (1 << (t - 1)) + 1;
		}
		t++;
		len >>= 1;
	}

	cout << ans << '\n';
}
*/

void st_find()
{
	//st表的创建，目的是快速查询某区间的最值
	//下面讨论如何准确定位区间，以及找到最值。

	//定义所查区间[l,r]
	int l, r;
	cin >> l >> r;

	int len = r - l + 1;   //区间长度
	//所查区间可以分为st[l,p] st[x,p]两个小区间
	//这两个小区间可以重叠，只要求这两个小区间的最值即可找到答案
	//首先，p是区间长度内最大的2的次方，即
	//2^p<=len  =>  p=(int)(log(len))/(log(2))
	//第二个小区间已知右端点,小区将长度依然可以是p，不会超过界限
	//所以  l=r - 2^p + 1
	int p = (int)(log(len)) / log(2);
	int ans = min(st[l][p], st[r - (1 << p) + 1][p]);
	cout << ans;
}


int main()
{
	cin >> n;
	init();
	st_set();
	st_out();
	st_find();
	return 0;
}